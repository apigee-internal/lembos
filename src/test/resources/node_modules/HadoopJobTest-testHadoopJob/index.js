'use strict';

var assert = require('assert');
var Configuration = require('hadoop-configuration').Configuration;
var Job = require('hadoop-job').Job;

function testNewJob() {
  // Test with wrong arguments
  try {
    new Job('');
  } catch (err) {
    assert.equal('First argument must be a Configuration object', err.message);
  }

  // Test different constructor options
  var conf = new Configuration();

  assert.ok(new Job() instanceof Job);
  assert.ok(new Job(conf) instanceof Job);
  assert.ok(new Job(conf, 'Test-Job-Name') instanceof Job);
}

function testGetConfiguration() {
  var job = new Job();
  var conf = job.getConfiguration();
  var prop = 'testGetConfiguration.property';
  var propVal = 'testGetConfiguration';

  assert.ok(conf instanceof Configuration);

  conf.set(prop, propVal);

  assert.equal(propVal, job.getConfiguration().get(prop));
}

function testGetCounters() {
  try {
    new Job().getCounters();
  } catch (err) {
    assert.ok(err.message.indexOf('Job in state DEFINE instead of RUNNING') > -1);
  }
}

function testGetJar() {
  // We shouldn't concern ourselves with testing the Job logic
  new Job().getJar();
}

function testGetJobId() {
  // We shouldn't concern ourselves with testing the Job logic
  new Job().getJobId();
}

function testGetTrackingURL() {
  try {
    new Job().getTrackingURL();
  } catch (err) {
    assert.ok(err.message.indexOf('Job in state DEFINE instead of RUNNING') > -1);
  }
}

function testIsComplete() {
  try {
    new Job().isComplete();
  } catch (err) {
    assert.ok(err.message.indexOf('Job in state DEFINE instead of RUNNING') > -1);
  }
}

function testIsSuccessful() {
  try {
    new Job().isSuccessful();
  } catch (err) {
    assert.ok(err.message.indexOf('Job in state DEFINE instead of RUNNING') > -1);
  }
}

function testKillJob() {
  try {
    new Job().killJob();
  } catch (err) {
    assert.ok(err.message.indexOf('Job in state DEFINE instead of RUNNING') > -1);
  }
}

function testMapProgress() {
  try {
    new Job().mapProgress();
  } catch (err) {
    assert.ok(err.message.indexOf('Job in state DEFINE instead of RUNNING') > -1);
  }
}

function testReduceProgress() {
  try {
    new Job().reduceProgress();
  } catch (err) {
    assert.ok(err.message.indexOf('Job in state DEFINE instead of RUNNING') > -1);
  }
}

function testSetCancelDelegationTokenUponJobCompletion() {
  var job = new Job();

  // Test with wrong arguments
  try {
    job.setCancelDelegationTokenUponJobCompletion();
  } catch (err) {
    assert.equal('One argument expected', err.message);
  }

  try {
    job.setCancelDelegationTokenUponJobCompletion('true');
  } catch (err) {
    assert.equal('First argument must be a boolean', err.message);
  }

  assert.ok(job.setCancelDelegationTokenUponJobCompletion(true) instanceof Job);
}

function testGetSetCombinerClass() {
  var job = new Job();
  var badClassName = 'java.io.File';

  // Test with wrong arguments
  try {
    job.setCombinerClass();
  } catch (err) {
    assert.equal('One argument expected', err.message);
  }

  try {
    job.setCombinerClass(badClassName);
  } catch (err) {
    assert.ok(err.message.indexOf('java.io.File is not a valid org.apache.hadoop.mapreduce.Reducer') > -1);
  }

  assert.ok(job.setCombinerClass('io.apigee.lembos.mapreduce.LembosCombiner') instanceof Job);
  assert.equal('io.apigee.lembos.mapreduce.LembosCombiner', job.getCombinerClass());
}

function testGetSetGroupingComparatorClass() {
  var job = new Job();
  var badClassName = 'java.io.File';

  // Test with wrong arguments
  try {
    job.setGroupingComparatorClass();
  } catch (err) {
    assert.equal('One argument expected', err.message);
  }

  try {
    job.setGroupingComparatorClass(badClassName);
  } catch (err) {
    assert.ok(err.message.indexOf('java.io.File is not a valid org.apache.hadoop.io.RawComparator') > -1);
  }

  assert.ok(job.setGroupingComparatorClass('io.apigee.lembos.mapreduce.LembosGroupComparator') instanceof Job);
  assert.equal('io.apigee.lembos.mapreduce.LembosGroupComparator', job.getGroupingComparatorClass());
}

function testGetSetInputFormatClass() {
  var job = new Job();
  var badClassName = 'java.io.File';

  // Test with wrong arguments
  try {
    job.setInputFormatClass();
  } catch (err) {
    assert.equal('One argument expected', err.message);
  }

  try {
    job.setInputFormatClass(badClassName);
  } catch (err) {
    assert.ok(err.message.indexOf('java.io.File is not a valid org.apache.hadoop.mapreduce.InputFormat') > -1);
  }

  assert.ok(job.setInputFormatClass('org.apache.hadoop.mapreduce.lib.input.FileInputFormat') instanceof Job);
  assert.equal('org.apache.hadoop.mapreduce.lib.input.FileInputFormat', job.getInputFormatClass());
}

function testSetJarByClass() {
  var job = new Job();

  // Test with wrong arguments
  try {
    job.setJarByClass();
  } catch (err) {
    assert.equal('One argument expected', err.message);
  }

  assert.ok(job.setJarByClass('io.apigee.lembos.mapreduce.LembosMapper') instanceof Job);
}

function testGetSetJobName() {
  var job = new Job();

  // Test with wrong arguments
  try {
    job.setJobName();
  } catch (err) {
    assert.equal('One argument expected', err.message);
  }

  assert.ok(job.setJobName('Some Test Job') instanceof Job);
  assert.equal('Some Test Job', job.getJobName());
}

function testGetSetMapOutputKeyClass() {
  var job = new Job();
  var badClassName = 'java.io.File';

  // Test with wrong arguments
  try {
    job.setMapOutputKeyClass();
  } catch (err) {
    assert.equal('One argument expected', err.message);
  }

  try {
    job.setMapOutputKeyClass(badClassName);
  } catch (err) {
    assert.ok(err.message.indexOf('java.io.File is not a valid org.apache.hadoop.io.WritableComparable') > -1);
  }

  assert.ok(job.setMapOutputKeyClass('org.apache.hadoop.io.Text') instanceof Job);
  assert.equal('org.apache.hadoop.io.Text', job.getMapOutputKeyClass());
}

function testGetSetMapOutputValueClass() {
  var job = new Job();
  var badClassName = 'java.io.File';

  // Test with wrong arguments
  try {
    job.setMapOutputValueClass();
  } catch (err) {
    assert.equal('One argument expected', err.message);
  }

  try {
    job.setMapOutputValueClass(badClassName);
  } catch (err) {
    assert.ok(err.message.indexOf('java.io.File is not a valid org.apache.hadoop.io.Writable') > -1);
  }

  assert.ok(job.setMapOutputValueClass('org.apache.hadoop.io.Text') instanceof Job);
  assert.equal('org.apache.hadoop.io.Text', job.getMapOutputValueClass());
}

function testGetSetMapperClass() {
  var job = new Job();
  var badClassName = 'java.io.File';

  // Test with wrong arguments
  try {
    job.setMapperClass();
  } catch (err) {
    assert.equal('One argument expected', err.message);
  }

  try {
    job.setMapperClass(badClassName);
  } catch (err) {
    assert.ok(err.message.indexOf('java.io.File is not a valid org.apache.hadoop.mapreduce.Mapper') > -1);
  }

  assert.ok(job.setMapperClass('io.apigee.lembos.mapreduce.LembosMapper') instanceof Job);
  assert.equal('io.apigee.lembos.mapreduce.LembosMapper', job.getMapperClass());
}

function testSetMapSpeculativeExecution() {
  var job = new Job();

  // Test with wrong arguments
  try {
    job.setMapSpeculativeExecution();
  } catch (err) {
    assert.equal('One argument expected', err.message);
  }

  try {
    job.setMapSpeculativeExecution('true');
  } catch (err) {
    assert.equal('First argument must be a boolean', err.message);
  }

  assert.ok(job.setMapSpeculativeExecution(true) instanceof Job);
}

function testGetSetNumReduceTasks() {
  var job = new Job();

  // Test with wrong arguments
  try {
    job.setNumReduceTasks();
  } catch (err) {
    assert.equal('One argument expected', err.message);
  }

  try {
    job.setNumReduceTasks('true');
  } catch (err) {
    assert.equal('First argument must be a number', err.message);
  }

  assert.ok(job.setNumReduceTasks(2) instanceof Job);
  assert.equal(2, job.getNumReduceTasks());
}

function testGetSetOutputFormatClass() {
  var job = new Job();
  var badClassName = 'java.io.File';

  // Test with wrong arguments
  try {
    job.setOutputFormatClass();
  } catch (err) {
    assert.equal('One argument expected', err.message);
  }

  try {
    job.setOutputFormatClass(badClassName);
  } catch (err) {
    assert.ok(err.message.indexOf('java.io.File is not a valid org.apache.hadoop.mapreduce.OutputFormat') > -1);
  }

  assert.ok(job.setOutputFormatClass('org.apache.hadoop.mapreduce.lib.output.FileOutputFormat') instanceof Job);
  assert.equal('org.apache.hadoop.mapreduce.lib.output.FileOutputFormat', job.getOutputFormatClass());
}

function testGetSetOutputKeyClass() {
  var job = new Job();
  var badClassName = 'java.io.File';

  // Test with wrong arguments
  try {
    job.setOutputKeyClass();
  } catch (err) {
    assert.equal('One argument expected', err.message);
  }

  try {
    job.setOutputKeyClass(badClassName);
  } catch (err) {
    assert.ok(err.message.indexOf('java.io.File is not a valid org.apache.hadoop.io.WritableComparable') > -1);
  }

  assert.ok(job.setOutputKeyClass('org.apache.hadoop.io.Text') instanceof Job);
  assert.equal('org.apache.hadoop.io.Text', job.getOutputKeyClass());
}

function testGetSetOutputValueClass() {
  var job = new Job();
  var badClassName = 'java.io.File';

  // Test with wrong arguments
  try {
    job.setOutputValueClass();
  } catch (err) {
    assert.equal('One argument expected', err.message);
  }

  try {
    job.setOutputValueClass(badClassName);
  } catch (err) {
    assert.ok(err.message.indexOf('java.io.File is not a valid org.apache.hadoop.io.Writable') > -1);
  }

  assert.ok(job.setOutputValueClass('org.apache.hadoop.io.Text') instanceof Job);
  assert.equal('org.apache.hadoop.io.Text', job.getOutputValueClass());
}

function testGetSetPartitionerClass() {
  var job = new Job();
  var badClassName = 'java.io.File';

  // Test with wrong arguments
  try {
    job.setPartitionerClass();
  } catch (err) {
    assert.equal('One argument expected', err.message);
  }

  try {
    job.setPartitionerClass(badClassName);
  } catch (err) {
    assert.ok(err.message.indexOf('java.io.File is not a valid org.apache.hadoop.mapreduce.Partitioner') > -1);
  }

  assert.ok(job.setPartitionerClass('io.apigee.lembos.mapreduce.LembosPartitioner') instanceof Job);
  assert.equal('io.apigee.lembos.mapreduce.LembosPartitioner', job.getPartitionerClass());
}

function testGetSetReducerClass() {
  var job = new Job();
  var badClassName = 'java.io.File';

  // Test with wrong arguments
  try {
    job.setReducerClass();
  } catch (err) {
    assert.equal('One argument expected', err.message);
  }

  try {
    job.setReducerClass(badClassName);
  } catch (err) {
    assert.ok(err.message.indexOf('java.io.File is not a valid org.apache.hadoop.mapreduce.Reducer') > -1);
  }

  assert.ok(job.setReducerClass('io.apigee.lembos.mapreduce.LembosReducer') instanceof Job);
  assert.equal('io.apigee.lembos.mapreduce.LembosReducer', job.getReducerClass());
}

function testSetReduceSpeculativeExecution() {
  var job = new Job();

  // Test with wrong arguments
  try {
    job.setReduceSpeculativeExecution();
  } catch (err) {
    assert.equal('One argument expected', err.message);
  }

  try {
    job.setReduceSpeculativeExecution('true');
  } catch (err) {
    assert.equal('First argument must be a boolean', err.message);
  }

  assert.ok(job.setReduceSpeculativeExecution(true) instanceof Job);
}

function testGetSetSortComparatorClass() {
  var job = new Job();
  var badClassName = 'java.io.File';

  // Test with wrong arguments
  try {
    job.setSortComparatorClass();
  } catch (err) {
    assert.equal('One argument expected', err.message);
  }

  try {
    job.setSortComparatorClass(badClassName);
  } catch (err) {
    assert.ok(err.message.indexOf('java.io.File is not a valid org.apache.hadoop.io.RawComparator') > -1);
  }

  assert.ok(job.setSortComparatorClass('io.apigee.lembos.mapreduce.LembosSortComparator') instanceof Job);
  assert.equal('io.apigee.lembos.mapreduce.LembosSortComparator', job.getSortComparatorClass());
}

function testSetSpeculativeExecution() {
  var job = new Job();

  // Test with wrong arguments
  try {
    job.setSpeculativeExecution();
  } catch (err) {
    assert.equal('One argument expected', err.message);
  }

  try {
    job.setSpeculativeExecution('true');
  } catch (err) {
    assert.equal('First argument must be a boolean', err.message);
  }

  assert.ok(job.setSpeculativeExecution(true) instanceof Job);
}

function testSetupProgress() {
  try {
    new Job().setupProgress();
  } catch (err) {
    assert.ok(err.message.indexOf('Job in state DEFINE instead of RUNNING') > -1);
  }
}

function testGetSetWorkingDirectory() {
  var job = new Job();
  var path = require('path').resolve('.');

  // Test with wrong arguments
  try {
    job.setWorkingDirectory();
  } catch (err) {
    assert.equal('One argument expected', err.message);
  }

  assert.ok(job.setWorkingDirectory(path) instanceof Job);
  assert.equal('file:' + path, job.getWorkingDirectory());
}

function testSubmit() {
  assert.ok(typeof new Job().submit === 'function');
}

function testWaitForCompletion() {
  assert.ok(typeof new Job().waitForCompletion === 'function');
}

module.exports.testHadoopJob = function (job, cb) {

  assert.ok(job instanceof Job);

  try {
    testNewJob();
    testGetConfiguration();
    testGetCounters();
    testGetJar();
    testGetJobId();
    testGetTrackingURL();
    testIsComplete();
    testIsSuccessful();
    testKillJob();
    testMapProgress();
    testReduceProgress();
    testSetCancelDelegationTokenUponJobCompletion();
    testGetSetCombinerClass();
    testGetSetGroupingComparatorClass();
    testGetSetInputFormatClass();
    testSetJarByClass();
    testGetSetJobName();
    testGetSetMapOutputKeyClass();
    testGetSetMapOutputValueClass();
    testGetSetMapperClass();
    testSetMapSpeculativeExecution();
    testGetSetNumReduceTasks();
    testGetSetOutputFormatClass();
    testGetSetOutputKeyClass();
    testGetSetOutputValueClass();
    testGetSetPartitionerClass();
    testGetSetReducerClass();
    testSetReduceSpeculativeExecution();
    testGetSetSortComparatorClass();
    testSetSpeculativeExecution();
    testSetupProgress();
    testGetSetWorkingDirectory();
    testSubmit();
    testWaitForCompletion();
  } catch (err) {
    if (err.stack) {
      console.error(err.stack);
    }
    throw new Error(err.message);
  }

  cb();

};