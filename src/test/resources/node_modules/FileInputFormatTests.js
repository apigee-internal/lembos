'use strict';

var assert = require('assert');
var Job = require('hadoop-job').Job;

function testAddInputPath (format) {
  var job = new Job();
  var inputPath = '/tmp/wordcount/4300.txt';

  // Test wrong arguments
  try {
    format.addInputPath();
  } catch (err) {
    assert.equal('Two arguments expected', err.message);
  }

  try {
    format.addInputPath(job);
  } catch (err) {
    assert.equal('Two arguments expected', err.message);
  }

  try {
    format.addInputPath(null, inputPath);
  } catch (err) {
    assert.equal('First argument is not optional', err.message);
  }

  try {
    format.addInputPath(job, null);
  } catch (err) {
    assert.equal('Second argument is not optional', err.message);
  }

  try {
    format.addInputPath('job', inputPath);
  } catch (err) {
    assert.equal('First argument must be a Job object', err.message);
  }

  // Test

  assert.deepEqual(format.getInputPaths(job), []);

  format.addInputPath(job, inputPath);

  assert.deepEqual(format.getInputPaths(job), ['file:' + inputPath]);
}

function testAddInputPaths (format) {
  var job = new Job();
  var inputPathsStr = '/tmp/file0.txt,/tmp/file1.txt';
  var inputPathsArr = [
      'file:/tmp/file0.txt',
      'file:/tmp/file1.txt'
  ];

  // Test wrong arguments
  try {
    format.addInputPaths();
  } catch (err) {
    assert.equal('Two arguments expected', err.message);
  }

  try {
    format.addInputPaths(job);
  } catch (err) {
    assert.equal('Two arguments expected', err.message);
  }

  try {
    format.addInputPaths(null, inputPathsStr);
  } catch (err) {
    assert.equal('First argument is not optional', err.message);
  }

  try {
    format.addInputPaths(job, null);
  } catch (err) {
    assert.equal('Second argument is not optional', err.message);
  }

  try {
    format.addInputPaths('job', inputPathsStr);
  } catch (err) {
    assert.equal('First argument must be a Job object', err.message);
  }

  // Test

  assert.deepEqual(format.getInputPaths(job), []);

  format.addInputPaths(job, inputPathsStr);

  assert.deepEqual(format.getInputPaths(job), inputPathsArr);
}

function testGetInputPathFilter (format) {
  var job = new Job();

  // Test wrong arguments
  try {
    format.getInputPathFilter();
  } catch (err) {
    assert.equal('One argument expected', err.message);
  }

  try {
    format.getInputPathFilter(null);
  } catch (err) {
    assert.equal('First argument is not optional', err.message);
  }

  try {
    format.getInputPathFilter('job');
  } catch (err) {
    assert.equal('First argument must be a Job object', err.message);
  }

  // Test

  assert.ok(!format.getInputPathFilter(job));
}

function testGetMaxSplitSize (format) {
  var job = new Job();

  // Test wrong arguments
  try {
    format.getMaxSplitSize();
  } catch (err) {
    assert.equal('One argument expected', err.message);
  }

  try {
    format.getMaxSplitSize(null);
  } catch (err) {
    assert.equal('First argument is not optional', err.message);
  }

  try {
    format.getMaxSplitSize('job');
  } catch (err) {
    assert.equal('First argument must be a Job object', err.message);
  }

  // Test

  assert.ok(format.getMaxSplitSize(job) > 0);
}

function testGetMinSplitSize (format) {
  var job = new Job();

  // Test wrong arguments
  try {
    format.getMinSplitSize();
  } catch (err) {
    assert.equal('One argument expected', err.message);
  }

  try {
    format.getMinSplitSize(null);
  } catch (err) {
    assert.equal('First argument is not optional', err.message);
  }

  try {
    format.getMinSplitSize('job');
  } catch (err) {
    assert.equal('First argument must be a Job object', err.message);
  }

  // Test

  assert.equal(format.getMinSplitSize(job), 0);
}

function testSetInputPathFilter (format) {
  var job = new Job();
  var pathFilterClass = 'org.apache.hadoop.mapred.OutputLogFilter';

  // Test wrong arguments
  try {
    format.setInputPathFilter();
  } catch (err) {
    assert.equal('Two arguments expected', err.message);
  }

  try {
    format.setInputPathFilter(job);
  } catch (err) {
    assert.equal('Two arguments expected', err.message);
  }

  try {
    format.setInputPathFilter(null, pathFilterClass);
  } catch (err) {
    assert.equal('First argument is not optional', err.message);
  }

  try {
    format.setInputPathFilter(job, null);
  } catch (err) {
    assert.equal('Second argument is not optional', err.message);
  }

  try {
    format.setInputPathFilter('job', pathFilterClass);
  } catch (err) {
    assert.equal('First argument must be a Job object', err.message);
  }

  try {
    format.setInputPathFilter(job, 'org.apache.hadoop.io.Text');
  } catch (err) {
    assert.equal('org.apache.hadoop.io.Text is not a valid org.apache.hadoop.fs.PathFilter', err.message);
  }

  // Test

  format.setInputPathFilter(job, pathFilterClass);

  assert.equal(format.getInputPathFilter(job), pathFilterClass);
}

function testSetInputPaths (format) {
  var job = new Job();
  var inputPathsStr = '/tmp/file0.txt,/tmp/file1.txt';
  var inputPathsArr = ['/tmp/file2.txt', '/tmp/file3.txt'];

  // Test wrong arguments
  try {
    format.setInputPaths();
  } catch (err) {
    assert.equal('Two arguments expected', err.message);
  }

  try {
    format.setInputPaths(job);
  } catch (err) {
    assert.equal('Two arguments expected', err.message);
  }

  try {
    format.setInputPaths(null, inputPathsStr);
  } catch (err) {
    assert.equal('First argument is not optional', err.message);
  }

  try {
    format.setInputPaths(job, null);
  } catch (err) {
    assert.equal('Second argument is not optional', err.message);
  }

  // Test

  format.setInputPaths(job, inputPathsStr);

  assert.deepEqual(format.getInputPaths(job), [
    'file:/tmp/file0.txt',
    'file:/tmp/file1.txt'
  ]);

  format.setInputPaths(job, inputPathsArr);

  assert.deepEqual(format.getInputPaths(job), [
    'file:/tmp/file2.txt',
    'file:/tmp/file3.txt'
  ]);
}

function testSetMaxInputSplitSize (format) {
  var job = new Job();

  // Test wrong arguments
  try {
    format.setMaxInputSplitSize();
  } catch (err) {
    assert.equal('Two arguments expected', err.message);
  }

  try {
    format.setMaxInputSplitSize(job);
  } catch (err) {
    assert.equal('Two arguments expected', err.message);
  }

  try {
    format.setMaxInputSplitSize(null, 1);
  } catch (err) {
    assert.equal('First argument is not optional', err.message);
  }

  try {
    format.setMaxInputSplitSize(job, null);
  } catch (err) {
    assert.equal('Second argument is not optional', err.message);
  }

  try {
    format.setMaxInputSplitSize('job', 1);
  } catch (err) {
    assert.equal('First argument must be a Job object', err.message);
  }

  try {
    format.setMaxInputSplitSize(job, '1');
  } catch (err) {
    assert.equal('Second argument must be a number', err.message);
  }

  // Test

  format.setMaxInputSplitSize(job, 1);

  assert.equal(format.getMaxSplitSize(job), 1);
}

function testSetMinInputSplitSize (format) {
  var job = new Job();

  // Test wrong arguments
  try {
    format.setMinInputSplitSize();
  } catch (err) {
    assert.equal('Two arguments expected', err.message);
  }

  try {
    format.setMinInputSplitSize(job);
  } catch (err) {
    assert.equal('Two arguments expected', err.message);
  }

  try {
    format.setMinInputSplitSize(null, 1);
  } catch (err) {
    assert.equal('First argument is not optional', err.message);
  }

  try {
    format.setMinInputSplitSize(job, null);
  } catch (err) {
    assert.equal('Second argument is not optional', err.message);
  }

  try {
    format.setMinInputSplitSize('job', 1);
  } catch (err) {
    assert.equal('First argument must be a Job object', err.message);
  }

  try {
    format.setMinInputSplitSize(job, '1');
  } catch (err) {
    assert.equal('Second argument must be a number', err.message);
  }

  // Test

  format.setMinInputSplitSize(job, 1);

  assert.equal(format.getMinSplitSize(job), 1);
}

module.exports.testFileInputFormat = function (format) {

  try {
    testAddInputPath(format);
    testAddInputPaths(format);
    testGetInputPathFilter(format);
    testGetMaxSplitSize(format);
    testGetMinSplitSize(format);
    testSetInputPathFilter(format);
    testSetInputPaths(format);
    testSetMaxInputSplitSize(format);
    testSetMinInputSplitSize(format);
  } catch (err) {
    if (err.stack) {
      console.error(err.stack);
    }
    throw new Error(err.message);
  }


};