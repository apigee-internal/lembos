'use strict';

var assert = require('assert');
var Job = require('hadoop-job').Job;

function testGetCompressOutput (format) {
  var job = new Job();

  // Test wrong arguments
  try {
    format.getCompressOutput();
  } catch (err) {
    assert.equal('One argument expected', err.message);
  }

  try {
    format.getCompressOutput(null);
  } catch (err) {
    assert.equal('First argument is not optional', err.message);
  }

  try {
    format.getCompressOutput('job');
  } catch (err) {
    assert.equal('First argument must be a Job object', err.message);
  }

  assert.equal('boolean', typeof format.getCompressOutput(job));
}

function testGetOutputCompressorClass (format) {
  var job = new Job();
  var outputCompressorClass = 'org.apache.hadoop.io.compress.DefaultCodec';

  // Test wrong arguments
  try {
    format.getOutputCompressorClass();
  } catch (err) {
    assert.equal('Two arguments expected', err.message);
  }

  try {
    format.getOutputCompressorClass(job);
  } catch (err) {
    assert.equal('Two arguments expected', err.message);
  }

  try {
    format.getOutputCompressorClass(null, outputCompressorClass);
  } catch (err) {
    assert.equal('First argument is not optional', err.message);
  }

  try {
    format.getOutputCompressorClass(job, null);
  } catch (err) {
    assert.equal('Second argument is not optional', err.message);
  }

  try {
    format.getOutputCompressorClass('job', outputCompressorClass);
  } catch (err) {
    assert.equal('First argument must be a Job object', err.message);
  }

  try {
    format.getOutputCompressorClass(job, 'org.apache.hadoop.io.Text');
  } catch (err) {
    assert.equal('org.apache.hadoop.io.Text is not a valid org.apache.hadoop.io.compress.CompressionCodec', err.message);
  }

  // Test
  assert.equal(outputCompressorClass, format.getOutputCompressorClass(job, outputCompressorClass));
}

function testGetOutputPath (format) {
  var job = new Job();

  // Test wrong arguments
  try {
    format.getOutputPath();
  } catch (err) {
    assert.equal('One argument expected', err.message);
  }

  try {
    format.getOutputPath(null);
  } catch (err) {
    assert.equal('First argument is not optional', err.message);
  }

  try {
    format.getOutputPath('job');
  } catch (err) {
    assert.equal('First argument must be a Job object', err.message);
  }

  // Test
  assert.ok(!format.getOutputPath(job));
}

function testSetCompressOutput (format) {
  var job = new Job();

  // Test wrong arguments
  try {
    format.setCompressOutput();
  } catch (err) {
    assert.equal('Two arguments expected', err.message);
  }

  try {
    format.setCompressOutput(null);
  } catch (err) {
    assert.equal('Two arguments expected', err.message);
  }

  try {
    format.setCompressOutput(null, false);
  } catch (err) {
    assert.equal('First argument is not optional', err.message);
  }

  try {
    format.setCompressOutput(job, null);
  } catch (err) {
    assert.equal('Second argument is not optional', err.message);
  }

  try {
    format.setCompressOutput('job', false);
  } catch (err) {
    assert.equal('First argument must be a Job object', err.message);
  }

  try {
    format.setCompressOutput(job, 'false');
  } catch (err) {
    assert.equal('Second argument must be a boolean', err.message);
  }

  var compressOutput = format.getCompressOutput(job);

  format.setCompressOutput(job, !compressOutput);

  assert.ok(format.getCompressOutput(job) === !compressOutput);
}

function testSetOutputCompressorClass (format) {
  var job = new Job();
  var outputCompressorClass = 'org.apache.hadoop.io.compress.BZip2Codec';

  // Test wrong arguments
  try {
    format.setOutputCompressorClass();
  } catch (err) {
    assert.equal('Two arguments expected', err.message);
  }

  try {
    format.setOutputCompressorClass(job);
  } catch (err) {
    assert.equal('Two arguments expected', err.message);
  }

  try {
    format.setOutputCompressorClass(null, outputCompressorClass);
  } catch (err) {
    assert.equal('First argument is not optional', err.message);
  }

  try {
    format.setOutputCompressorClass(job, null);
  } catch (err) {
    assert.equal('Second argument is not optional', err.message);
  }

  try {
    format.setOutputCompressorClass('job', outputCompressorClass);
  } catch (err) {
    assert.equal('First argument must be a Job object', err.message);
  }

  try {
    format.setOutputCompressorClass(job, 'org.apache.hadoop.io.Text');
  } catch (err) {
    assert.equal('org.apache.hadoop.io.Text is not a valid org.apache.hadoop.io.compress.CompressionCodec', err.message);
  }

  // Test
  format.setOutputCompressorClass(job, outputCompressorClass);

  assert.equal(outputCompressorClass,
               format.getOutputCompressorClass(job, 'org.apache.hadoop.io.compress.DefaultCodec'));
}

function testSetOutputPath (format) {
  var job = new Job();
  var outputPath = '/tmp/output';

  // Test wrong arguments
  try {
    format.setOutputPath();
  } catch (err) {
    assert.equal('Two arguments expected', err.message);
  }

  try {
    format.setOutputPath(job);
  } catch (err) {
    assert.equal('Two arguments expected', err.message);
  }

  try {
    format.setOutputPath(null, outputPath);
  } catch (err) {
    assert.equal('First argument is not optional', err.message);
  }

  try {
    format.setOutputPath(job, null);
  } catch (err) {
    assert.equal('Second argument is not optional', err.message);
  }

  try {
    format.setOutputPath('job', outputPath);
  } catch (err) {
    assert.equal('First argument must be a Job object', err.message);
  }

  // Test
  format.setOutputPath(job, outputPath);

  assert.equal(outputPath, format.getOutputPath(job));
}

module.exports.testFileOutputFormat = function (format) {

  try {
    testGetCompressOutput(format);
    testGetOutputCompressorClass(format);
    testGetOutputPath(format);
    testSetCompressOutput(format);
    testSetOutputCompressorClass(format);
    testSetOutputPath(format);

    // TODO: Add test for getPathForWorkFile(TaskInputOutputContext, String, String)
    // TODO: Add test for getWorkOutputPath(TaskInputOutputContext)
  } catch (err) {
    if (err.stack) {
      console.error(err.stack);
    }
    throw new Error(err.message);
  }

};